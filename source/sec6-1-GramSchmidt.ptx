<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="sec6-1-GramSchmidt" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Gram-Schmidt Orthogonalization</title>

  
    <p>
     In this section, we look at how to construct an 
     orthogonal basis of <m>\R^n</m> from a basis. 
    </p>
 
  <p>
    Let <m>\{v_1,\ldots, v_n\}</m> be a basis of <m>\R^n</m>.
    Define
    <md>
      <mrow>u_1:  =\amp  v_1</mrow>
      <mrow>u_2:  =\amp  v_2 -\frac{u_2\cdot u_1}{\norm{u_1}^2}u_1</mrow>
      <mrow>u_3:  =\amp  v_3 -\frac{v_3\cdot u_1}{\norm{u_1}^2}u_1-\frac{v_3\cdot u_2}{\norm{u_2}^2}u_2</mrow>
      <mrow> \amp  \vdots</mrow>
      <mrow>u_n:  =\amp  v_n -\frac{v_n\cdot u_1}{\norm{u_1}^2}u_1-\cdots -\frac{v_n\cdot u_{n-1}}{\norm{u_{n-1}}^2}u_{n-1}</mrow>
    </md>
  </p>
  <p>
    In view of Ex.
    <xref ref="orth-ex2-1"></xref>,
    it is easy to see that <m>\{u_1,\ldots,
    u_n\}</m> is an orthogonal basis of <m>\R^n</m>.
    Now we normalize <m>u_i's</m>.
    Define <m>q_i=\frac{u_i}{\norm{u_i}}</m>.
    Then <m>\{q_1,\cdots, q_n\}</m> is an orthononal basis of <m>\R^n</m>.
    Note that we could have defined <m>q_i</m> immediately after defining <m>u_i</m>.
  </p>
  <p>
    This process is called the <em>Gram-Schmidt orthogonalization process</em>.
  </p>

  <p>
    Geometrically <m>u_2</m>,
    constructed by subtracting the orthogonal projection of <m>v_2</m> on to <m>u_1</m>.
    In order to construct <m>u_3</m>,
    we take sum of orthogonal projections of <m>v_3</m> onto <m>u_1</m> and <m>u_2</m>,
    which is the orthogonal projection of the plane spanned by <m>u_1</m> and <m>u_2</m> and subtract this from <m>v_3</m>.
    Readers are encouraged to draw figures. Also explore the Sage interact 
    applet by changing the basis vectors. 
  </p>
 <figure xml:id="figure-Gram-Schmidt-Applet1">
    <caption>Goemetry of Linear Tranformation</caption>
    <interactive dark-mode-enabled="yes" xml:id="Gram-Schmidt-Applet1" platform="sage" width="100%" aspect="1:1">
      <slate surface="sage">
      @interact
      def gram_schmidt_with_projection_lines(
          v1=input_box([2,1,0], label="$v_1$"),
          v2=input_box([1,0,1], label="$v_2$"),
          v3=input_box([0,1,2], label="$v_3$"),
          normalize=True
      ):
          # Convert inputs
          v1 = vector(v1)
          v2 = vector(v2)
          v3 = vector(v3)
          
          # Step 1: u1
          u1 = v1
          
          # Step 2: subtract projection of v2 on u1
          proj_v2_u1 = (v2*u1)/(u1*u1) * u1
          u2 = v2 - proj_v2_u1
          
          # Step 3: subtract projections of v3 on u1, u2
          proj_v3_u1 = (v3*u1)/(u1*u1) * u1
          proj_v3_u2 = (v3*u2)/(u2*u2) * u2
          u3 = v3 - proj_v3_u1 - proj_v3_u2
          
          if normalize:
              u1 = u1/u1.norm()
              u2 = u2/u2.norm()
              u3 = u3/u3.norm()
          
          # Plotting
          plots = []
          
          # Original basis (red)
          for v, lab in zip([v1,v2,v3], ["v1", "v2", "v3"]):
              plots.append(arrow3d((0,0,0), v, color="red", thickness=2))
              plots.append(text3d(lab, v*1.1, color="red", fontsize=14))
          
          # Orthogonal basis (blue)
          for u, lab in zip([u1,u2,u3], ["q1", "q2", "q3"]):
              plots.append(arrow3d((0,0,0), u, color="blue", thickness=4))
              plots.append(text3d(lab, u*1.1, color="blue", fontsize=14))
          
          # Projections as arrows (green dashed)
          for proj, lab in zip(
              [proj_v2_u1, proj_v3_u1, proj_v3_u2],
              ["P_q1(v2)", "P_q1(v3)", "P_q2(v3)"]
          ):
              plots.append(arrow3d((0,0,0), proj, color="green", thickness=2, linestyle="dashed"))
        
          
          # Projection lines (green dotted from vector tip to projection point)
          plots.append(line3d([v2, proj_v2_u1], color="green", thickness=2, linestyle="dotted"))
          plots.append(line3d([v3, proj_v3_u1], color="green", thickness=2, linestyle="dotted"))
          plots.append(line3d([v3, proj_v3_u2], color="green", thickness=2, linestyle="dotted"))
          
          # Show
          show(sum(plots), aspect_ratio=1, frame=False, viewer="threejs")

      </slate>
      </interactive>
  </figure>

<example>
    <statement>
      <p>
        Consider a linearly independ set of 
        vectors <m>v_1=(2,1)</m> and <m>v_2=(2,4)</m>. 
        Refer to <xref ref="Gram_Schmidt_2d_fig1"/> to see the geometric meaning 
        of the Gram-Schmidt orthogonalization in <m>\R^2</m>. 
          
    <figure xml:id="Gram_Schmidt_2d_fig1">
      <sidebyside width="40%">
        <image source="images/Gram_Schmidt_2d"/>
      </sidebyside>
      <caption>Gram-Schmidt Orthogonalization in <m>\R^2</m>.
      </caption>
    </figure>
   </p>
    </statement>
  
  </example>
 

  
  <example xml:id="gram-schmidt-eg1">
    <statement>
      <p>
        Use the Gram-Schmidt orthogonalization process to find an orthonormal basis of <m>\R^3</m> starting with a basis <m>\{(0,1,1), (1,1,1), (1,-2,2)\}</m>.
        Let <m>v_1 = (0, 1, 1), v_2=(1, 1, 1), v_3=(1, -2, 2)</m>.
        Then we have
        <md>
          <mrow>u_1: = \amp (0, 1, 1)</mrow>
          <mrow>u_2:  = \amp v_2 -\frac{u_2\cdot u_1}{\norm{u_1}^2}u_1=(1, 1, 1)-\frac{2}{2}(0,1,1)=(1,0,0)</mrow>
          <mrow>u_3:= \amp v_3 -\frac{u_3\cdot u_1}{\norm{u_1}^2}u_1-\frac{u_3\cdot u_2}{\norm{u_2}^2}u_2</mrow>
          <mrow> =  \amp (1, -2, 2)-\frac{0}{2}(0,1,1)-\frac{1}{1}(1,0,0)=(0,-2,2)</mrow>
        </md>
      </p>
 
      <p>
        Thus the orthonormal basis obtained from the given basis is
        <me>
          \left\{q_1 = \left(0, \frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}\right), q_2=(1,0,0), q_3 =\left(0,\frac{-1}{\sqrt{2}},\frac{1}{\sqrt{2}}\right)\right\}
        </me>.
      </p>
    <sage>
      <input>
        v1 = vector([0, 1, 1])
        v2 = vector([1, 1, 1])
        v3 = vector([1,-2,2])
        u1 = v1
        u2 = v2 -v2.dot_product(u1)/norm(u1)^2*u1;print(u2)
        u3 = v3 -v3.dot_product(u1)/norm(u1)^2*u1-v3.dot_product(u2)/norm(u2)^2*u2;print(u3)
        q1 = u1/norm(u1);q2 = u2/norm(u2);q3=u3/norm(u3)
        print(q1,q2,q3)
        ## Checking orthogonality of q1,q2,q3
        Q = column_matrix([q1,q2,q3])
        Q.T*Q
      </input>
      <output>
        
      </output>
    </sage>
  </statement>
    
</example>

  <example xml:id="gram-schmidt-eg2">
    <statement>
      <p>
        Consider the matrix <m>A=\left(\begin{array}{rrrr} -1 \amp 1 \amp 0 \amp 1 \\ 1 \amp -1 \amp 0 \amp 1 \\ -1 \amp 0 \amp 2 \amp 1 \end{array} \right)</m>.
        Find an orthogonal basis of the row space of <m>A</m>.
        It is easy to check that rank of <m>A</m> is 3.
        Hence row are linearly independent vectors in <m>\R^4</m>.
      </p>

      <p>
        Let
        <m>
          v_1=(-1,1,0,1), v_2 = (1,-1,0,1),   v_3=(-1,0,2,1)
        </m>.
        <md><mrow>u_1: = \amp (-1,1,0,1)</mrow>
          <mrow>u_2: =  \amp v_2 -\frac{u_2\cdot u_1}{\norm{u_1}^2}u_1</mrow>
           <mrow> =\amp (1,-1,0,1)-\frac{-1}{3}(-1,1,0,1)=(2/3, -2/3, 0, 4/3)</mrow>
          <mrow>u_3: = \amp  v_3 -\frac{u_3\cdot u_1}{\norm{u_1}^2}u_1-\frac{u_3\cdot u_2}{\norm{u_2}^2}u_2</mrow>
          <mrow>  = \amp  (-1,0,2,1)-\frac{2}{3}(-1,1,0,1)-\frac{2/3}{9/2}(2/3, -2/3, 0, 4/3)</mrow>
          <mrow>=\amp (-1/2, -1/2, 2, 0)
          </mrow>
        </md>
      </p>

      <p>
        Hence
        <me>
          \{(-1, 1, 0, 1), (2/3, -2/3, 0, 4/3), (-1/2, -1/2, 2, 0)\}
        </me>
        is an orthogonal basis of the row space of <m>A</m>.
      </p>

      <sage>
        <input>
          A = matrix([[-1,1,0,1],[1,-1,0,1],[-1,0,2,1]])
RowSpace = A.row_space()
print(RowSpace)
print(RowSpace.basis())
B = A.rows()
q1 = B[0]
q2 = B[1]-B[1].dot_product(q1)/q1.norm()^2*q1
q3 = B[2]-B[2].dot_product(q1)/q1.norm()^2*q1-B[2].dot_product(q2)/q2.norm()^2*q2
print(q1,q2,q3)
        </input>
        <output>
          
        </output>
      </sage>
      <p>
        Sage also has an inbuilt method for Gramm-Schmidt orthogonalization process. For example, 
        <c>A.gram_schmidt()</c> performs Gram-Schmidt orthogonalization on the rows of the matrix,
   <m>A</m> returning a new matrix and a matrix accomplishing the
   transformation. 
      </p>

      <sage>
        <input>
          Q, R= A.gram_schmidt()
          print(Q)
          print(R)
        </input>
        <output>
          
        </output>
      </sage>
      <p>
Here <m>Q</m> is the matrix whose rows are nothing but orthogonal vectors obtained by Gram-Schmidt and 
<m>R</m> is an upper triangular matrix. We shall see meaning of <m>R</m> and how it is obtained in 
later sections.
      </p>

    </statement>
  </example>

  <exercise>
    <statement>
      <p>
        Use the Gram-Schmidt orthogonalization process to find an orthonormal basis of <m>\R^3</m> starting with a basis <m>\beta=\{(1,1,1),(-1,1,1),(-1,0,1)\}</m>.
      </p>
    </statement>
  </exercise>
  
  <exercise>
    <statement>
      <p>
        Use the Gram-Schmidt orthogonalization process to find an orthonormal basis of the subspace <m>W\subset \R^4</m> with basis
        <me>
          \beta = \{ (-1,1,1,0),(-1,0,1,0),(1,0,0,1)\}
        </me>.
      </p>
    </statement>
  </exercise>
  
  <activity>
    <title>Sage Routine for Gram-Schmidt Orthogonalizatio</title>
    <p>
    Let us create a Sage routine to find an orthogonal basis from a set of linearly independent set 
    of vecrors <m>S=\{v_1,\ldots,v_k\}</m>. 
    </p>
    <sage>
      <input>
    def proj(v, u):
        p = v.dot_product(u)/(norm(u)^2)*u
        return(p)
    
    def Gram_Schmidt(S):
        n = len(S)
        E=[S[0]/norm(S[0]).n()]
        for k in range(1,n):
            q = S[k]-sum([proj(S[k],E[i]) for i in range(k)])
            E.append(q/norm(q).n(digits=5))
        return(E)
      </input>
      <output>
        
      </output>
    </sage>

    <p>
      Now let us call the above function.
    </p>

      <sage>
        <input>
      v1 = vector([2, -1, 3, 1])
      v2 = vector([3, 3, 4, 0])
      v3 = vector([1, -2, 0, -1])
      v4 = vector([4, 5, 5, -1]) 
      S = [v1,v2,v3,v4]   
      GS = Gram_Schmidt(S)
      ML = column_matrix(GS)
      show(ML) 
        </input>
        <output>
          
        </output>
      </sage>
 <p>
  We can check if the set of vectors thus orbtained is orthonormal?
  <sage>
    <input>
      import numpy as np
      print(np.dot(ML,ML.T).round())
    </input>
    <output>
      
    </output>
  </sage>
 </p>   
  </activity>
  <sage>
    <input>
      ## Sage Practice Area
      # Take a basis in R^3 and find the orthnormal basis using 
      # the Gram-Schmidt orthogonalization 

    </input>
    <output>
      
    </output>
  </sage>
  <sage>
    <input>
    ## Sage Practice Area
    # Take a basis in R^4 and find the orthnormal basis using 
    # the Gram-Schmidt orthogonalization 

    </input>
    <output>
      
    </output>
  </sage>
</section>
