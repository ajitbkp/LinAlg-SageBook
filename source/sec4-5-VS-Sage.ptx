<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="sec-sec4-5-VS-Sage" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Sage Computations</title>

<introduction>
    <p>
        In this section, we demonstrate how Sage can be utilized to define vector spaces and perform computations involving vectors. We shall explore various concepts related to vector spaces that have been introduced in this chapter. The majority of the computations will be carried out in the vector spaces 
        <m>\mathbb{Q}^n</m>, <m>\mathbb{R}^n</m> and 
        <m>\mathbb{C}^n</m>. Additionally, we shall examine certain concepts pertaining to the vector space <m>{\mathcal{P}}_n(\mathbb{R})</m>.         
    </p> 
    <p>
        To define a vector space <m>\mathbb{Q}^n</m> in Sage, one may use <c>QQ^n</c> or <c>VectorSpace(QQ, n)</c>. Similarly, the vector spaces  <m>\mathbb{Q}^n</m> and <m>\mathbb{C}^n</m> can be defined using <c>RR^n</c> and <c>CC^n</c>, respectively. Sage provides built-in functions for generating the linear span of a set of vectors, checking their linear dependence, and determining the coordinates of a vector with respect to a given basis. Nevertheless, we will also employ the Reduced Row Echelon Form (RREF) to explore various concepts such as subspaces, linear dependence and independence, and the computation of coordinates.
    </p>
</introduction>

<example label="sec4-5-VS-eg1">
 <title>Vector space <m>\mathbb{Q}^6</m></title>
 <statement>
    <p>
     Let us define the vector space <m>\mathbb{Q}^6</m> and explore the various concepts in Sage. 

     Define 5 vectors <m>v_1=\left(1,\,-1,\,2,\,3,\,1,\,4\right)
</m>, <m>v_2=(\left(2,\,1,\,0,\,2,\,-3,\,1\right),)
</m>, <m>v_3=(\left(-4,\,-5,\,4,\,0,\,11,\,5\right),)
</m>, <m>v_4=(\left(-1,\,0,\,2,\,1,\,3,\,2\right),)
</m> and <m>v_5=(\left(-2,\,-2,\,4,\,2,\,7,\,5\right),)
</m>. Find the linear span of <m>B=\{v_1,v_2,v_3,v_4,v_5\}</m>. Check of <m>B</m> is a linearly independent set. 
    </p>
 </statement>
</example>
 <p>
    We can use the following sage commands to define the <m>\mathbb{Q}^6</m>.
 </p>

 <sage>
    <input>
        V = QQ^4;V
    </input>
    <output>
        Vector space of dimension 6 over Rational Field       
    </output>
 </sage>
 
 <sage>
    <input>
        V = VectorSpace(QQ,6);V
    </input>
    <output>
        Vector space of dimension 6 over Rational Field       
    </output>
 </sage>
 Let explore few methods on the object <c>V</c>. Use can use V.TAB to get the 
 drop down menue of methods.

 <sage>
    <input>
     V.an_element()  # Returns an element of this parent V.
      </input>
    <output>
        
    </output>
 </sage>

 <sage>
    <input>
        V.random_element() # Returns a random vector of V.
    </input>
    <output>
        
    </output>
 </sage>
The following methods returns the base filed (Rational Field in this case).
 <sage>
    <input>
        V.base()
        V.base_field()
    </input>
    <output>
        
    </output>
 </sage>

 <sage>
    <input>
        V1 = V.base_extend(RR) # Used to extend the base field to real field.
        V1.random_element()
    </input>
    <output>
        
    </output>
 </sage>

 <sage>
    <input>
        V.basis_matrix() # Returns the basis matrix of V.
    </input>
    <output>
        
    </output>
 </sage>

 <sage>
    <input>
        V.basis() # Returns the standard basis of V.
    </input>
    <output>
        
    </output>
 </sage>

 <sage>
    <input>
        V.dimension() # Returns the dimension of V.
    </input>
    <output>
        
    </output>
 </sage>
 <p> 
    Try to explore more methods on the object <c>V</c>.
 </p>

 <p>
    Now let us define vectors in <m>V</m>.
 </p>

 <sage>
    <input>
        V = QQ^6
        v1 = vector([1,-1,2,3,1,4])
        v2 = vector([2,1,0,2,-3,1])
        v3 = vector([-4,-5,4,0,11,5])
        v4 = vector([-1,0,2,1,3,2])
        v5 = vector([-2,-2,4,2,7,5])
        v1 in V
    </input>
    <output>
        
    </output>
 </sage>
 <p> 
    Next, let us define the linear span of <m>B=\{v_1,\ldots, v_5\}</m>.
 </p>

 <sage>
    <input>
        B = [v1,v2,v3,v4,v5]
        W = V.span(B)
        W
    </input>
    <output>
        
    </output>
 </sage>
 <p>
    We can check if <c>W</c> is a subspace of <c>V</c>.
 </p>
 <sage>
    <input>
        W.is_subspace(V)
    </input>
    <output>
        
    </output>
 </sage>
 <p>
    Note that a basis of the <m>L(B)</m> can be also obtained by 
 applying RREF on the matrix whose rows are vectors, <m>v_1,\ldots, v_5</m>.
 </p>

 <sage>
    <input>
        A = column_matrix([v1,v2,v3,v4,v5]).T
        A.rref()
    </input>
    <output>
        
    </output>
 </sage>
 <p>
    Notice that the 1st three rows of the above output consitute the 
    basis of the <m>L(B</m>.
 </p>

 <p>
    Next let us check whether the set of vecors <m>B</m> is linearly dependent using the following Sage syntax.
 </p>

 <sage>
    <input>
        S = V.linear_dependence(B);S
    </input>
    <output>
        
    </output>
 </sage>
 <p>
    If the set is linearly indepensent then <c>S = V.linear_dependence(B);S</c> returns an empty list. However, if <m>B</m> is linearly dependent then 
    it returs a list of scalars (possibly more than on1), say <m>\alpha_1,\cdots,\alpha_5</m> such that <m>\sum v_i\alpha_i=0</m>. Let us verift the same.
 </p>

 <sage>
    <input>
        print(V.linear_combination([(B[i],S[0][i]) for i in range(5)]))
        print(V.linear_combination([(B[i],S[1][i]) for i in range(5)]))
    </input>
    <output>
        
    </output>
 </sage>

 <exercise>
        <statement>
            <p>
                Repeat the above example on the vector space <m>\mathbb{R}^6</m>.
            </p>
        </statement>
     </exercise>

     <example>
        <statement>
            <p>
                Let <m>V=\mathbb{Q}^4</m> be a vector space. Let <m>{\cal B}=\{(1,0,0,0),(1,1,0,0,),(1,0,-1,0),(0,0,0,1)\}</m>. Check if <m>{\cal B}</m> is linearly independent. 
Consider a vector <m>v=(-1,2,3,-2)</m>. Find the coordinates of <m>v</m> with respect to <m>{\cal B}</m>.  

            </p>
        </statement>

     </example>

     <solution>
        <p>
            Let us solve this problem in Sage.
        </p>

        <sage>
            <input>
                V=QQ^4
                v1=vector(QQ,[1,0,0,0])
                v2=vector(QQ,[1,1,0,0])
                v3=vector(QQ,[1,0,-1,0])
                v4=vector(QQ,[0,0,0,1])
                B=[v1,v2,v3,v4]
                S = V.linear_dependence(B);S
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            Since <m>S</m> is an empty list, <m>B</m> is a linearly independent set.
        </p>

        <p>
            Next, we define a subspace with <m>B</m> as a basis and then 
            find the coordinates of the vector <m>v</m> with respect to <m>B</m>.
        </p>

        <sage>
            <input>
                V=V.subspace_with_basis(B)
                v=vector(QQ,[-1,2,3,-2])
                V.coordinates(v)
            </input>
            <output>
                
            </output>
        </sage>

        <p>
            We can also find the coordinate vector of <m>v</m>. 
        </p>

        <sage>
            <input>
                V.coordinate_vector(v)
            </input>
            <output>
                
            </output>
        </sage>
        We cal also find the coordinates of <m>v</m> using RREF.

        <sage>
            <input>
                column_matrix(B).augment(v,subdivide=True).rref()
            </input>
            <output>
                
            </output>
        </sage>
        The last columns of the above output is the coordinate vector.
     </solution>

     <example>
        <statement>
            <p>
              Let <m>V=\mathbb{Q}^4</m> be a vector space. Let <me>
                {\cal B}=\{(1,0,0,0),(1,1,0,0,),(1,0,-1,0),(0,0,0,1)\}
              </me>
               and
<me>{\cal C}=\{(1,1,1,0),(1,1,0,1),(1,0,1,1),(1,1,1,-1)\}</me> be two bases of <m>V</m>. Find the change of basis matrix <m>M_{\cal B}^{\cal C}</m> and the change of basis matrix <m>M_{\cal C}^{\cal B}</m>. Consider a vector <m>v=(-1,2,3,-2)</m>. Suppose <m>c_{\cal B}</m> be the coordinate vector of <m>v</m> with respect to the basis <m>{\cal B}</m> and <m>v_{\cal C}</m> be the coordinate vector of <m>v</m> with respect to the basis <m>{\cal C}</m>. Verify that <m>v_{\cal C}=M_{\cal B}^{\cal C}v_{\cal B}</m>.
            </p>
        </statement>
     </example>

     <solution>
        <p>
            Let us solve the above problem in Sage. Note that 
            the matrix <m>M_{\cal B}^{\cal C}</m> can be obtained in many ways.
            One way, is to find this by writing the matrix of whose columns are 
            the coordinate vectors of each vector in <m>{\cal B}</m> with respect
            to <m>{\cal B}</m>.  

            Alternatively, we can use RREF on <m>[{\cal C}~ {\cal B}</m> and 
            take the last four columns of the same.
    
        </p>

        <sage>
            <input>
                V=QQ^4
                v1=vector(QQ,[1,0,0,0])
                v2=vector(QQ,[1,1,0,0])
                v3=vector(QQ,[1,0,-1,0])
                v4=vector(QQ,[0,0,0,1])
                B=[v1,v2,v3,v4]
                V=V.subspace_with_basis(B)
                v=vector(QQ,[-1,2,3,-2])
                v_B=V.coordinate_vector(v)
                print(v_B)
            </input>
            <output>
                
            </output>
        </sage>

        <sage>
            <input>
                V=QQ^4
                w1=vector(QQ,[1,1,1,0])
                w2=vector(QQ,[1,1,0,1])
                w3=vector(QQ,[1,0,1,1])
                w4=vector(QQ,[1,1,1,-1])
                C=[w1,w2,w3,w4]
                W=V.subspace_with_basis(C)
                v=vector(QQ,[-1,2,3,-2])
                v_C=W.coordinate_vector(v)
                print(v_C)
            </input>
            <output>
                
            </output>
        </sage>

        <sage>
            <input>
                M_BC=column_matrix([W.coordinates(B[i]) for i in range(4)])
                print(M_BC)
            </input>
            <output>
                
            </output>
        </sage>
        <p>
            Next we find the change of basis matrix using RREF.
        </p>

        <sage>
            <input>
                BB=column_matrix(B)
                CC=column_matrix(C)
                NN=CC.augment(BB,subdivide=True)
                NN.rref()[:,4:]
            </input>
            <output>
                
            </output>
        </sage>

        <sage>
            <input>
                M_CB=column_matrix([V.coordinates(C[i]) for i in range(4)])
                print(M_CB)
            </input>
            <output>
                
            </output>
        </sage>

        <sage>
            <input>
                BB=column_matrix(B)
                CC=column_matrix(C)
                MM=BB.augment(CC,subdivide=True) 
                MM.rref()[:,4:]
            </input>
            <output>
                
            </output>
        </sage>

        <p>
            Let us verify that <m>v_{\cal C}=M_{\cal B}^{\cal C}v_{\cal B}</m>.
        </p>

        <sage>
            <input>
                v_C==M_BC*v_B
            </input>
            <output>
                
            </output>
        </sage>

        <p>
            The change of basis matrix <m>M_{\cal B}^{\cal C}</m>, can be also 
            otained by finding the matrix of the identity linear  transformation 
            <m>Id: \mathbb{Q}^4\to \mathbb{Q}^4</m> and find its matrix with respect to the basis <m>{\cal B}</m> of the domain and <m>{\cal C}</m> on the codomain.
        </p>

        <sage>
            <input>
                V = QQ^4
                T = linear_transformation(identity_matrix(4),V,V)
                v1=vector(QQ,[1,0,0,0])
                v2=vector(QQ,[1,1,0,0])
                v3=vector(QQ,[1,0,-1,0])
                v4=vector(QQ,[0,0,0,1])
                B=[v1,v2,v3,v4]
                U=V.subspace_with_basis(B)
                w1=vector(QQ,[1,1,1,0])
                w2=vector(QQ,[1,1,0,1])
                w3=vector(QQ,[1,0,1,1])
                w4=vector(QQ,[1,1,1,-1])
                C=[w1,w2,w3,w4]
                W=V.subspace_with_basis(C)
                S = T.restrict_domain(U).restrict_codomain(W)
                S.matrix(side='right')
            </input>
            <output>
                
            </output>
        </sage>
     </solution>

     <example>
        <title>The Dimesnion Formula</title>
        <statement>
            <p>
 Let <m></m>.  Let  <m>W_1</m> be a subspace spanned by <m>v_1=(-3, 1, -1, 2), v_2=(1, -1, 11, 3),  v_3=(-5, 1, 9, 7), v_4=(-1, 12, 5, 4)</m> and <m>W_2</m> be the subspace spanned by vectors <m>u_1=(3, -1, 5,  7), u_2 =(21, 11, 10, -13), u_3=(-2, 3, -51, 7), u_4=(-17, -10, -51, 34)</m>. Find bases and dimensions of  subspace <m>W_1+W_2</m> and <m>W_1\cap W_2</m>.
            </p>
        </statement>
        
     </example>

     <solution>
        <p>
            Let us solve the above problem using Sage.
        </p>

        <sage>
            <input>
                V = QQ^4 # vector space of dimension 4 over rational field
                v1=vector(QQ,[-3, 1, -1, 2])
                v2=vector(QQ,[1, -1, 11, 3])
                v3=vector(QQ,[-5, 1, 9, 7])
                v4=vector(QQ,[-1, 12, 5, 4])
                B1=[v1,v2,v3,v4]
                ## W1, Subspace spanned by v1,v2,v3,v4
                W1=V.span(B1);
                C1=W1.basis_matrix() # Basis of W1
                k=C1.dimensions()[0] # dimension of W1
            </input>
            <output>
                
            </output>
        </sage>

        <sage>
            <input>
                print("The dimesion of W1 is {}".format(k))
                print("A basis of W1 is:")
                print(C1)
            </input>
            <output>
                
            </output>
        </sage>

        <sage>
            <input>
                u1=vector(QQ,[3, -1, 5,  7])
                u2 =vector(QQ,[21, 11, 10, -13])
                u3=vector(QQ,[-2, 3, -51, 7])
                u4=vector(QQ,[-17, -10, -51, 34])
                B2=[u1,u2,u3,u4]
                ## W2, Subspace spanned by u1,u2,u3,u4
                W2=V.span(B2);
                C2=W2.basis_matrix() # Basis of W2
                p=C2.dimensions()[0] # dimension of W2
            </input>
            <output>
                
            </output>
        </sage>

        <sage>
            <input>
                print("The dimesion of W2 is {}".format(p))
                print("A basis of W2 is:")
                print(C2)
            </input>
            <output>
                
            </output>
        </sage>
            <p>
                <c>W1+W2</c> returns the space <m>W_1+W_2</m>.
            </p>
        
        <sage>
            <input>
                print(W1+W2)
                print((W1+W2).basis_matrix())
                print("The dimension of W1+W2 is {}".format(dimension(W1+W2)))
            </input>
            <output>
                
            </output>
        </sage>

        <p>Intersection of W1 and W2 using the inbuilt sage function <c>intersection</c></p>

        <sage>
            <input>
                U=W1.intersection(W2)
                print(U.basis_matrix()) # The basis of the intersection of W1 and W2
            </input>
            <output>
                
            </output>
        </sage>

        <p>
            Finally, we can verify the dimension formula.
        </p>

        <sage>
            <input>
                dimension(W1+W2)==dimension(W1)+dimension(W2)-dimension(W1.intersection(W2))
            </input>
            <output>
                
            </output>
        </sage>
     </solution>
     <subsection xml:id="subsec-polynomial-space-sage">
        <title>Polynomial Space in Sage</title>
       <introduction>
        <p>
             In this subsection we shall explore, how to work with the polynomial space 
        <m> {\mathcal{P}}_n(\mathbb{R})</m> in Sage. The main idea is to consider a polynomial 
        <m>p(x) =\sum_i^n a_i x^i</m> as a vecror <m>\left(a_0,a_1,\ldots,a_n\right)\in \mathbb{R}^{n+1}.</m>
        </p>
          <p>
        Sage provides ways to extract coefficents of a polynomail.  If <m>p(x)</m> is a 
        polynomial then <c>p(x).coefficients()</c> returns the list of coefficints and the corresponding
        degree in increasing order of degree.
        </p>

    </introduction>
      
        <sage>
            <input>
                p(x) = x^4-5*x^3+2*x-2
                p(x).coefficients() #Return the coefficients of this symbolic expression as a polynomial  in x
            </input>
            <output>
             [[-2, 0], [2, 1], [-5, 3], [1, 4]]   
            </output>
        </sage>
        <sage>
            <input>
                p(x) = 6
                p(x).coefficients()
            </input>
            <output>
             [[6, 0]]   
            </output>
        </sage>
        
        <p>
            There is a way to get only the coeffiencts as well as follows.
        </p>
        <sage>
            <input>
                p(x).coefficients(sparse=False) # returns only the coefficients
            </input>
            <output>
                [-2, 2, 0, -5, 1]
            </output>
        </sage>
        <p>
            Note that if <m>p</m> is a polynomial of degree <m>k</m>, then it can be also thought of as a vector in <m> {\mathcal{P}}_n(\mathbb{R})</m> for <m>m\geq k</m>. In order take care of this, let us create s sage routine as follow. 
        </p>

        <sage>
            <input>
                ## The following function returns the degress of a polynomial
                def Poly_Coeff(p,n):
                    L = p(x).coefficients()
                    LP=[0]*(n+1)
                    for i in range(len(L)):
                        k = L[i][1]
                        LP[k]=L[i][0]
                    return LP
            </input>
            <output>
                
            </output>
        </sage>
        
       <sage>
        <input>
        p(x)=1
        print(Poly_Coeff(p,1))
        p(x) = x^4-5*x^3+2*x-2
        print(Poly_Coeff(p,4))
        print(Poly_Coeff(p,6))

        </input>
        <output>
            
        </output>
       </sage>
       <p> 
        Next we write a Sage routine to find the degree of a polynomial.
    </p>
    <sage>
        <input>
        def Poly_Degree(p):
            L = p(x).coefficients()
            D = [L[i][1] for i in range(len(L))]
            return max(D)
        </input>
        <output>
            
        </output>
    </sage>
    <sage>
        <input>
            p(x) = 7
print(Poly_Degree(p))
p(x)=9-x^5
print(Poly_Degree(p))
        </input>
        <output>
            
        </output>
    </sage>
    <p>
    Now we write a Sage routine to check if a set of polynomial is linearly independent or 
    linearly dependent. How do we do this? Suppose <m> p_1(x), \ldots, p_k(x)</m> be polynomials 
    of degrees <m> n_1, n_2, \ldots, n_k</m> respectively. Let <m> n = \max\{deg(p_i)\} </m>. Then  
    <m>p_i(x)\in {\mathcal{P}}_n(\mathbb{R})</m> for each <m> i</m> and each <m> p_i</m> corresponds to 
    a vector <m>v_i \in \mathbb{R}^{n+1}</m>. Thus to check linearly dependency of <m> p_1(x),\ldots, p_k(x)</m>     amount to checking linearly dependency of <m> v_1,\ldots, v_k \in \mathbb{R}^{n+1}</m>. 
    </p> 

    <sage>
        <input>
        def Poly_linear_depend(L):
            k = len(L)
            n = max([Poly_Degree(L[i]) for i in range(k)])
            V = VectorSpace(RR,n+1)
            B = []
            for i in range(k):
               v = vector(Poly_Coeff(L[i],n))
               B.append(v)
            M = column_matrix(B)
            S = V.linear_dependence(B)
            if(rank(M)==k):
                print('These polynomials are linearly independent.')
            else:
                print('These polynomials are linearly dependent.')
            return(S)
        </input>
        <output>
            
        </output>
    </sage>
    <sage>
        <input>
            var('x')
p1(x) = 1+x + 3*x^2
p2(x) = 1 + 5*x^3 - 2*x^5
p3(x) = -5 + 3*x^2 + 32*x^4
p4(x) = x^3-4*x
p5(x) = x^3 - x^4
l = [p1, p2,p3, p4, p5]
Poly_linear_depend(l)
        </input>
        <output>
            
        </output>
    </sage>
    <sage>
        <input>
            var('x')
p1(x) = 1+x + 3*x^2
p2(x) = 1 + 5*x^3 - 2*x^5
p3(x) = -5 + 3*x^2 + 32*x^4
p4(x) = 5*x^5 + 128*x^4 - 14*x^3 + 18*x^2 + 2*x - 21
p5(x) = x^3 - x^5
l = [p1, p2, p3,p4, p5]
Poly_linear_depend(l)
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        Next we write a Sage routine to find the coordinates of a polynomial with respect 
        to a basis of a polynomial space.
    </p>
    <sage>
        <input>
            def Poly_Coordinates(p,B):
                k = len(B)
                n = max([Poly_Degree(B[i]) for i in range(k)])
                M = []
                u = vector(Poly_Coeff(p,n))
                for i in range(k):
                    v = vector(Poly_Coeff(B[i],n))
                    M.append(v)
                M.append(u)
                M1 = column_matrix(M)
                s = M1.rref()[:,k]
                return s
        </input>
        <output>
            
        </output>
    </sage>
    <sage>
        <input>
            var('x')
            p1(x) = 1+x^3
            p2(x) = x+x^2-x^3
            p3(x) = x^2-3*x^3
            p4(x) = x^3
            p(x)=7-3*x+x^2-6*x^3
            B = [p1,p2,p3,p4]
            Poly_Coordinates(p,B)
        </input>
        <output>
            
        </output>
    </sage>

    <sage>
        <input>
            var('x')
            p1(x) = 1
            p2(x) = x
            p3(x) = x^2
            p4(x) = x^3
            p(x)=7-3*x+x^2-6*x^3
            B = [p1,p2,p3,p4]
            Poly_Coordinates(p,B)
        </input>
        <output>
            
        </output>
    </sage>
    <p>
        Finally let us define a Sage routine to find the linear span of set of polynomials.
    </p>
    <sage>
        <input>
            def Poly_linspan(L, n):
                c = []
                k = len(L)
                for i in range(k):
                    co = Poly_Coeff(L[i],n)
                    c.append(co)
                B = column_matrix(c).T.rref()
                dim = B.rank()
                return (dim, B[:dim,:])
        </input>
        <output>
            
        </output>
    </sage>

    <sage>
        <input>
            q1(x)=1; q2(x)= x; q3(x)=x^2;q4(x)=x^3
            L = [q1,q2,q3,q4]
            dim,Basis  = Poly_linspan(L,3)
            Basis,dim
        </input>
        <output>
            
        </output>
    </sage>
    <sage>
        <input>
            p1(x)=2; p2(x)= 3*x^2-x; p3(x)=x^3- 2*x;p4(x)=x^3-3*x+3*x^2
            L = [p1,p2,p3,p4]
            dim,Basis = Poly_linspan(L,3)
            print(f'A basis matric of the linear span is\n{Basis}\n\nThe Dimesion of the subspace is {dim} ')
        </input>
        <output>
            
        </output>
    </sage>
    <remark>
        <p>
            Once we get the basis matrix of the subspace we can write the corresponding polynomials as 
            basis.
        </p>
    </remark>
    
     </subsection>

     <subsection xml:id="subsec-matrix-space">
        <title>Matrix Spaces in Sage</title>
        <introduction>
            <p>
                How to we work with matrix space in Sage? Note that if <m>A</m> is an <m>m\times n</m> real matrix, then we can think of this as a vector in <m>\mathbb{R}^{mn}</m> defined by stacking the entries row-by-row (or column-by-column). In particular, the matrix space <m>M(m,n,\mathbb{R})</m> is ismorphic to <m>\mathbb{R}^{mn}</m> via flattening map 
                <me>
                    \varphi \colon  M(m,n,\mathbb{R})\to \mathbb{R}^{mn}
                </me>
              defined by stacking the entries row-by-row (or column-by-column).
            </p>
            Thus if we have apply linear algebra concepts to a set of matrices <m>\{A_1,\ldots, A_k\}</m>, this amounts to applying the linear algebra concepts to <m>\{\varphi(A_1),\ldots, \varphi(A_k)\}</m>
            and taking <m>\varphi^{-1}</m> to the resultant vectors <m>M(m,n,\mathbb{R})</m>.  
        </introduction>        
<p>
    Let us first see how to convert a given matrix to <m>A</m> to the associated vector <m>v=\varphi(A)</m> and conversely, how to convert a given vector <m>v</m> to the associated matrix <m>A=\varphi^{-1}(v)</m> in sage. We define two Sage rountines. 
 <sage>
    <input>
        m, n = 3, 4
        MS = MatrixSpace(QQ, m,n)
        A = MS([[1, 2, 3,-1], [2,4, 5, 6],[5,0,-3,1]])
        A
    </input>
    <output>
        
    </output>
 </sage>

 <sage>
    <input>
        def mat_flatten(A):
            row = A.rows()
            v = []
            for r in row:
                v=v+flatten(r)
            return vector(v)
    </input>
    <output>
        
    </output>
 </sage>

 <sage>
    <input>
        mat_flatten(A)
    </input>
    <output>
        
    </output>
 </sage>

 <sage>
    <input>
        def mat_unflatten(v,m,n):
            MS = MatrixSpace(QQ, m,n)
            return MS(list(v))
    </input>
    <output>
        
    </output>
 </sage>

 <sage>
    <input>
    m, n = 3, 4
    MS = MatrixSpace(QQ, m,n)
    A = MS([[1, 2, 3,-1], [2,4, 5, 6],[5,0,-3,1]])
    mat_unflatten(mat_flatten(A),m,n)
    </input>
    <output>
        
    </output>
 </sage>
</p>
        <example>
            <p>
             Check if the set of matrices <m>\{A_1,A_2,A_3,A_4,A_5\}</m> where
             <me>
                A_1=\left(\begin{array}{rrrr}
0 \amp -1 \amp 0 \amp 1 \\
2 \amp -2 \amp -2 \amp -1 \\
\frac{1}{2} \amp -2 \amp 0 \amp 1
\end{array}\right), A_2=\left(\begin{array}{rrrr}
0 \amp \frac{1}{2} \amp 0 \amp -2 \\
0 \amp 0 \amp 0 \amp -1 \\
0 \amp 1 \amp 0 \amp -1
\end{array}\right),A_3 = \left(\begin{array}{rrrr}
0 \amp -1 \amp -2 \amp 0 \\
0 \amp -\frac{1}{2} \amp -1 \amp -1 \\
-2 \amp 0 \amp 1 \amp 2
\end{array}\right)</me>

<me>    A_4 = \left(\begin{array}{rrrr}
1 \amp \frac{1}{2} \amp 2 \amp -1 \\
-2 \amp 1 \amp 0 \amp 1 \\
-\frac{1}{2} \amp 0 \amp 0 \amp -1
\end{array}\right), A_5=\left(\begin{array}{rrrr}
-1 \amp -5 \amp -4 \amp 9 \\
6 \amp -\frac{11}{2} \amp -5 \amp -1 \\
-\frac{1}{2} \amp -7 \amp 1 \amp 8
\end{array}\right)
             </me>
     is linearly depedent in <m>M(3,r,\mathbb{Q})</m>.           
            </p>

            <solution>
                <p>
                    <sage>
                        <input>
                        A1 = MS([[0 , -1 , 0 , 1],[2 , -2 , -2 , -1 ],[1/2 , -2 , 0 , 1]])
                        A2 = MS([[0 , 1/2, 0 , -2 ],[0 , 0 , 0 , -1 ],[0 , 1 , 0 , -1]])
                        A3 =  MS([[ 0,-1 , -2 , 0 ],[0 , -1/2 , -1 , -1 ],[-2 , 0 , 1 , 2]])
                        A4 = MS([[1 , 1/2 , 2 , -1 ],[-2 , 1 , 0 , 1 ],[-1/2 , 0 , 0 , -1]])
                        A5 = MS([[-1 , -5 , -4 , 9 ],[6 , -11/2, -5 , -1 ],[-1/2 , -7 , 1 , 8]])
                        m,n = A1.dimensions()
                        V = VectorSpace(QQ,m*n)
                        B = [A1,A2,A3,A4,A5]
                        L=[]
                        for i in range(len(B)):
                            L.append(mat_flatten(B[i]))
                        V.linear_dependence(L)
                        </input>
                        <output>
                         [ 
                         (1, -3/2, 1/2, -1/2, -1/2)
                         ]   
                        </output>
                    </sage>

                    Clearly the above set of matrices are not linearly independent. In fact,
                    <me>
                        A_1-3/2A_2+1/2A_3-1/2A_4 -1/2A_5=0.
                    </me>
                    
                </p>
            </solution>
        </example>
        <exercise>
            <p>
                Write Sage rountines to find coordinates of a matrix with repect to a basis of a matrix space and also the to find the linear span of set of matrices.
            </p>
        </exercise>
     </subsection>
</section>
